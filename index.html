<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Parallel and Concurrent Haskell</title>

		<meta name="description" content="A presentation about Simon Marlow's book Parallel and Concurrent Haskell">
		<meta name="author" content="Andrew Clarkson">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Parallel and Concurrent Haskell</h2>
					<p>
						<small>by Andrew Clarkson / <a href="http://twitter.com/bitborn">@bitborn</a></small>
					</p>
				</section>

				<section>
                    <h2>Bad News</h2>
                    <p>The free lunch is over!</p>
				</section>

				<section>
                    <h2>Good News</h2>
                    <p>Haskell has solutions</p>
				</section>

				<section>
					<h2>Solutions</h2>
					<ul>
					    <li>Parallelism</li>
					    <li>Concurrency</li>
                        <li><b>Distributed Computing</b></li>
                    </ul>
				</section>
				
                <section>
					<h2>Parallelism vs. Concurrency</h2>
				    <p>Analogies...</p>
                </section>
                
                <section>
					<h2>... vs. Distributed Computing</h2>
					<ul>
					    <li>Communication</li>
					    <li>Failure</li>
                        <li>Consistency</li>
                    </ul>
				</section>
				
                <section>
					<h2>Determinism vs. Non-determinism</h2>
                </section>

				<section>
					<h2>Parallelism</h2>
                    <p>Two problems:</p>
                    <ol>
                        <li>Partitioning (Amdahl's Law)</li>
                        <li>Dependencies</li>
                    </ol>
                </section>

				<section>
                    <h2>Eval Example</h2>
                    <pre><code data-trim contenteditable>
import Control.Parallel.Strategies (runEval, rpar)

main :: IO ()
main = do
    let result = runEval $ do
        a &lt;- rpar $ fib 30
        b &lt;- rpar $ fib 31
        return (a, b)
    print result
    where
        fib 0 = 1
        fib 1 = 1
        fib x = fib (x - 1) + fib (x - 2)
        
                    </pre></code>
				</section>
				
                <section>
                    <h2>Par Monad Example</h2>
                    <pre><code data-trim contenteditable>
import Control.Monad.Par (runPar, new, fork, put, get)

main :: IO ()
main = do
    let result = runPar $ do
        a &lt;- new
        b &lt;- new
        fork $ put a (fib 30)
        fork $ put b (fib 31)
        a' &lt;- get a
        b' &lt;- get b
        return (a', b')
    print result
    where
        fib :: Int -&gt; Int
        fib 0 = 1
        fib 1 = 1
        fib x = fib (x - 1) + fib (x - 2)
        
                    </pre></code>
				</section>

				<section>
				    <h2>Data Parallelism Example</h2>
                    <pre><code data-trim contenteditable>
import Data.Array.Repa
import qualified Data.Array.Repa as Repa

main :: IO ()
main = do
    let y = fromListUnboxed ((Z :. 3 :. 3 :. 2) :: DIM3) [1..18]
        y' = Repa.zipWith (*) y y
    result &lt;- (computeP y') :: IO (Array U DIM3 Int)
    print result
                    </pre></code>
                </section>

				<section>
				    <h2>Concurrency</h2>
                    <p>Non-deterministic</p>
                    <p>Multi-tasking</p>
                    <p>Can implement parallelism</p>
                </section>
                
				<section>
				    <h2>Concurrent Example</h2>
                    <pre><code data-trim contenteditable>
import Control.Concurrent
import Data.ByteString as B
import GetURL

main = do
    a1 &lt;- async (getURL "http://www.wikipedia.org/wiki/Shovel")
    a2 &lt;- async (getURL "http://www.wikipedia.org/wiki/Spade")
    r1 &lt;- wait a1
    r2 &lt;- wait a2
    print (B.length r1, B.length r2)    
                    </pre></code>
                </section>

				<section>
                    <section>
				    <h2>Deterministic Example</h2>
                    <pre><code data-trim contenteditable>
import Control.Monad.Par (runPar, new, fork, put, get)

main :: IO ()
main = do
    let result = runPar $ do
        a &lt;- new
        fork $ put a (fib 31)
        fork $ put a (fib 1)
        a' &lt;- get a
        return a'
    print result
    where
        fib :: Int -&gt; Int
        fib 0 = 1
        fib 1 = 1
        fib x = fib (x - 1) + fib (x - 2)
                    </pre></code>
                    </section>
                    <section>
                        <h2>Results In</h2>
                        <pre>
$ ghc ./examples/racepar.hs -threaded 
$ ./examples/racepar +RTS -N2
racepar: multiple put
racepar: thread blocked indefinitely in an MVar operation 
                        </pre>
                    </section>
                </section> 
				<section>
                    <section>
				    <h2>Non-deterministic Example</h2>
                    <pre><code data-trim contenteditable>
import Control.Concurrent

main :: IO ()
main = do
    a &lt;- newEmptyMVar
    forkIO $ do
        putMVar a (fib 31)
    forkIO $ do
        putMVar a (fib 30)
    result &lt;- takeMVar a
    print result
    where
        fib :: Int -&gt; Int
        fib 0 = 1
        fib 1 = 1
        fib x = fib (x - 1) + fib (x - 2)

                    </pre></code>
                    </section>
                    <section>
                        <h2>Results In</h2>
                        <pre>
$ ghc ./examples/racecon.hs -threaded 
$ ./examples/racecon +RTS -N2
???
                        </pre>
                    </section>
                </section> 
            <section>
                <h2>Distributed Haskell</h2>
                <p>Plays to Haskell's strengths</p>
            </section>
            
            <section>
                <section>
                <h2>Message Type</h2>
                <pre><code data-trim contenteditable>
data Message = Ping ProcessId
             | Pong ProcessId deriving (Typeable, Generic)

instance Binary Message
                </code></pre>
                </section>
                
                <section>
                <h2>Server</h2>
                <pre><code data-trim contenteditable>
pingServer :: Process ()
pingServer = do
    Ping to &lt;- expect
    say "ping."
    from &lt;- getSelfPid
    send to (Pong from)

remotable ['pingServer]
                </code></pre>
                </section>
                
                <section>
                <h2>Master</h2>
                <pre><code data-trim contenteditable>
master :: [NodeId] -&gt; Process ()
master = do
    node &lt;- getSelfNode
  
    to &lt;- spawn node $(mkStaticClosure 'pingServer)
    from &lt;- getSelfPid
    send to (Ping from)
    
    Pong _ &lt;- expect 
    say "pong."

    terminate
                </code></pre>
                </section>
                <section>
                <h2>Main</h2>
                <pre><code data-trim contenteditable>
main :: IO ()
main = do
    backend <- initializeBackend "localhost" "4444" initRemoteTable
    startMaster backend master

                </code></pre>
                </section>
            </section>



            </div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
